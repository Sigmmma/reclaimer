Current speed of OBJECTS.PS2: 40KB/s

High Priority:


Finish docstrings for modules and update existing ones.

Need to make it so that readers/writers/decoders/encoders have better
handling of exceptions and give better details regarding the exception.
    Do this for the whole library in general where necessary

    Place try/except around all encoding routines to catch and report errors better

    Make it so when an error is first raised, a special exception type is raised with
    an appended message saying which block the exception occurred while trying to read.
        The error text can be like:
            "Exception occurred while trying to read '%s'" % b_desc.get(NAME)
        and for every reader outside of it an additonal string will be appended to
        the error saying " in '%s'" % b_desc.get(NAME)

Make sanitization function an attribute in the Field_Type under the name "Sanitizer".
    The Field_Type.Sanitizer() will get called whenever encountered in a descriptor


Medium Priority:

Make a Union Field and a UnionBlock that allows specifying
multiple descriptors for how to decode/encode the data.
    The actual data will be stored in a bytearray object under self.Val and is
    decoded  on the fly to give the intended object.
    When each attribute is set, only the part of the bytearray that it resides
    in will be set, meaning if it only takes up the first 2 bytes of a 4 byte union,
    only the first 2 bytes will be affected, and the last 2 will remain the same

    Can't do anything about changing the ordering of the bytes because it would
    be possible to make the largest attribute be a 4 char 32bit string, but have
    the other entries be endianness reliant things.

Make a Wrapper Field and a WrapperBlock that allows wrapping a block(s) in another
block which has methods for reading and editing the data of the inner block(s).
    An example would be a wrapper that treats an int as a utc timestamp
    or a different wrapper that treats a float as a utc timestamp.

    Another would be a wrapper for ip addressing that treats a series of 4 bytes
    either 4 unsigned 8-bit ints, or a string in the format "AAA.BBB.CCC.DDD"


Low Priority:

Make Bin_Size recursion safe

Implement recursive pointer based blocks.
    When writing, pass around a dictionary of which block IDs have already had
    their pointers calculated and what the pointer value is. When a reused block
    is about to have its corrosponding pointer set, it will instead use the
    pointer that already exists. When the block is being written, a dictionary
    will be passed around with which block ID was written to which location.
    If an ID already exists in the dictionary, the block is not written.

    When reading, a dictionary of pointers to blocks is passed around. When a
    pointer is read that exists in the dictionary keys, the corrosponding
    block in the dictionary is used instead of reading it from the file again.

    Make it so that Pointer32/64 are set to 0 when their pointed to block DNE

Make it so that a definitions folder must be located in the same module as __main__



##################
## HALO RELATED ##
##################

Make descriptor for weapon hud tag
Make descriptor for unit hud tag
Make descriptor for grenade hud tag
Make descriptor for hud_globals tag

make program to load all hud, shader_environment, shader_model, and bitmap 
tags it can find, load all bitmaps referenced within those tags, pass them 
to the bitmap convertor with settings specifying how to convert them.
*shader_environment requires the bump maps to be turned into P-8 bump
*shader_model requires multipurpose maps to have their channels swapped
(this also means change the channel usage enum in the shader_model


## MAP RIPPING ##
When ripping a map with deprotect on, make a "Requires" set and a 
"Required_By" list for each tag. The Requires set will contain the
Tag_IDs of all tags that the tag requires to have valid names before
it is written and the value in the Required_By list will be a list of all
blocks that point to that Tag_ID.

When scanning through the tags, add each non-null Tag_Index_Ref
block to the Required_By list of the tag it points to, and add the Tag_ID
of the tag it points to to the current tag's Requires set. Set each of those
Tag_Index_Ref blocks Tag_Path_Pointer to 0 and Tag_ID fields to
0xFFFFFFFF. Set each of the Reflexive blocks ID and Reflexive_ID to 0
as well as the same kind of fields in Raw_Data_Ref.

When done, write the meta data of all the tags whose Tag_IDs have an empty 
Requires set to a BytearrayBuffer(not including the tag header), and make 
a hash of the buffer. Use this hash to find the name of the tag in the Hash_Cache
and, if it fails, name it heuristically. Replace the Tag_Path string of all blocks
that depend on it with the new name and(in a separate series of lists) remove
the name from lists that say "some_tag" depends on that tag.

Check each tag to see which ones have an empty Requires set and run the
above paragraph of steps on it. Repeat this process until all tags have
been written. If there is a point where no tags have an empty Requires
set, either name it heuristically or ask the user what to name it.

MAKE SURE TO REMOVE Compressed_Color_Plate_Data from bitmap tags
when making their hashes as well as compressed vertices in models and bsp

make sure to null the tag class in tag references that dont exist so that the
hashes still work with smokescreen protected maps.
## MAP RIPPING ##


Remaining tagdefs:
    'actr':".actor"
    'actv':".actor_varient"
    'ant!':".antenna"
    'bipd':".biped"
    'cdmg':".continuous_damage_effect"
    'cont':".contrail"
    'deca':".decal"
    'udlg':".dialogue"
    'dobc':".detail_object_collection"
    'ctrl':".device_control"
    'lifi':".device_light_fixture"
    'mach':".device_machine"
    'jpt!':".damage_effect"
    'effe':".effect"
    'eqip':".equipment"
    'font':".font"
    'garb':".garbage"
    'mod2':".gbxmodel"
    'matg':".globals"
    'glw!':".glow"
    'grhi':".grenade_hud_interface"
    'hudg':".hud_globals"
    'lens':".lens_flare"
    'ligh':".light"
    'mgs2':".light_volume"
    'elec':".lightning"
    'mode':".model"
    'coll':".model_collision_geometry"
    'obje':".object"
    'part':".particle"
    'pctl':".particle_system"
    'phys':".physics"
    'plac':".placeholder"
    'proj':".projectile"
    'scnr':".scenario"
    'sbsp':".scenario_structure_bsp"
    'scen':".scenery"
    'snd!':".sound"
    'lsnd':".sound_looping"
    'ssce':".sound_scenery"
    'sotr':".shader_transparent_generic"
    'sky ':".sky"
    'DeLa':".ui_widget_definition"
    'unit':".unit"
    'unhi':".unit_hud_interface"
    'vehi':".vehicle"
    'vcky':".virtual_keyboard"
    'weap':".weapon"
    'wphi':".weapon_hud_interface"
    'rain':".weather_particle_system"



##################
## HALO RELATED ##
##################



BITMAP MODULE TODO:

Make sure the linear size is computed correctly for DDS headers
Finish DDS importer
Incorporate CHANNEL_ORDER into raw packers and unpackers. use it by
	getting which index A, R, G, and B are in and use those
	indexes as the locations to place the unpacked channels into

	not sure how I'm going to incorporate it in non raw formats(DXT)

Make setting to use same palette for all mipmaps of a bitmap
Write palettized mipmap generator.
    make it so that a palette can be supplied to the 
    mipmap generator so it already has one to work from




GNUerilla Ideas:

create "UNITS" and make it accept an object which defines a 
way to display the data(bytes, KB, MB, degrees, radians, etc).
	Make it so the first entry in the Units is the default
	unit and all other ones base themselves around it

Undo system that works by using a redo deque and undo deque object
	https://docs.python.org/2/library/collections.html#deque-objects

	Need an object which has these properties:
		list to hold all the blocks that are changed
		list to hold all the previous block values
		list to hold which index of each block was changed