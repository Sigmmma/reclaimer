Current speed of OBJECTS.PS2: 45KB/s

High Priority:
    
Make a "Switch" Field_Type that allows you to specify
a function which will determine which descriptor to use.
    do this by making the Switch have a reader which chooses from a list of
    possible structures and uses a provided function to decide which one to use.
    The Switch doesnt create its own Tag_Block, but instead calls the reader of
    the proper Tag_Block with the same args and kwargs that were provided to it.

    the SELECTOR must be a fully fledged function that accepts arguments

    make switch reader function take care of CARRY_OFF

    make a Simple_Switch Field_Type. 
    Instead of having to provide a function that handles getting the data from the
    Raw_Data/Tag_Data and tries to find the matching descriptor, it instead does:
        Desc.get(Parent.Get_Meta('SELECTOR'), Empty_Block)

make an immutable dictionary class called a "Descriptor"
    Descriptors will require a custom set method such as Replace() which will take
    the changes being given to it and return a copy of itself with the changes
    made. The reason for this is because __setattr__() cant return anything.

    Do the above for __setattr__, __delattr__, __setitem__, and __delitem__

Finish docstrings for modules and update existing ones.

Move Tag_Obj.py into supyr_struct

Make Bin_Size recursion safe


Medium Priority:

Make a Union Field_Type that allows specifying multiple descriptors for how to
decode/encode the data.
    The actual data will be stored in a bytearray object under self.Val and is
    decoded  on the fly to give the intended object.
    When each attribute is set, only the part of the bytearray that it resides
    in will be set, meaning if it only takes up the first 2 bytes of a 4 byte union,
    only the first 2 bytes will be affected, and the last 2 will remain the same

Need to make it so that readers/writers/decoders/encoders have better
handling of exceptions and give better details regarding the exception.
    Do this for the whole library in general where necessary

    place try/except around all encoding routines to catch and report errors better

Make wrapper class for reading/writing any memoryview-able object.
    This will allow writing to non-files

    put this in Builder.py


Low Priority:

Improve speed of Enum_Block by including a mapping of Value:Index in enumerator
descriptors under the name VALUE_MAP. This will make it so its not necessary to
check every option, but will require adjustments to get_desc, set_desc, del_desc

Make it possible to call a Field_Type and provide a Name string
followed by a calling of all the Field_Types of each of its fields.
    This will return a constructor type object that, when called with
    the proper arguments, will return a fully constructed Tag_Block.

    Make it possible to get/set the descriptor of these constructor objects

    This will be a good alternative for those who don't want to use the
    JSON style dict definition method, though all of the keyword arguments
    will need to go after all the fields have been specified, thus the
    keyword arguments like GUI_NAME and POINTER will be at the bottom


Speed up library by making special Tag_Blocks for each hierarchy type and
remove all the checks for Field_Type as they will become unnecessary
    somehow remove Reader, Writer, Encoder, Decoder, and Size_Calc from
    the Field_Type class and make a factory function that builds the
    class with those methods directly set, that way it doesnt have
    to go through an intermediary function to get the class reference


Implement recursive pointer based blocks.
    When writing, pass around a dictionary of which block IDs have already had
    their pointers calculated and what the pointer value is. When a reused block
    is about to have its corrosponding pointer set, it will instead use the
    pointer that already exists. When the block is being written, a dictionary
    will be passed around with which block ID was written to which location.
    If an ID already exists in the dictionary, the block is not written.

    When reading, a dictionary of pointers to blocks is passed around. When a
    pointer is read that exists in the dictionary keys, the corrosponding
    block in the dictionary is used instead of reading it from the file again.

    Make it so that Pointer32/64 are set to 0 when their pointed to block DNE


Try to make a mutable Tag_Block object that can be used to allow objects to
have variables other than their structure properties. This approach should
still use a descriptor so that accessing structure elements is done in the
same way, code is less bloated, and some other reasons I can't remember atm.
    THIS CAN BE DONE BY MAKING ONE OF THE SLOTS BE '__dict__'

    Will need to make some modified functions for this block __deepcopy__ and
    __copy__ so that they also take into account the __dict__ slot.
    Will also need modified __setattr__, __delattr__, __getitem__, __setitem__,
    and __delitem__ that each check __dict__ before checking DESC or __slots__



############
HALO RELATED
############

Make descriptor for weapon hud tag
Make descriptor for unit hud tag
Make descriptor for grenade hud tag
Make descriptor for hud_globals tag

make program to load all hud, shader_environment, shader_model, and bitmap 
tags it can find, load all bitmaps referenced within those tags, pass them 
to the bitmap convertor with settings specifying how to convert them.
*shader_environment requires the bump maps to be turned into P-8 bump
*shader_model requires multipurpose maps to have their channels swapped
(this also means change the channel usage enum in the shader_model

############
HALO RELATED
############



BITMAP MODULE TODO:

Make sure the linear size is computed correctly for DDS headers
Finish DDS importer
Incorporate CHANNEL_ORDER into raw packers and unpackers. use it by
	getting which index A, R, G, and B are in and use those
	indexes as the locations to place the unpacked channels into

	not sure how I'm going to incorporate it in non raw formats(DXT)


Make setting to use same palette for all mipmaps of a bitmap
Write palettized mipmap generator.
    make it so that a palette can be supplied to the 
    mipmap generator so it already has one to work from




GNUerilla Ideas:

create "UNITS" and make it accept an object which defines a 
way to display the data(bytes, KB, MB, degrees, radians, etc).
	Make it so the first entry in the Units is the default
	unit and all other ones base themselves around it

Undo system that works by using a redo deque and undo deque object
	https://docs.python.org/2/library/collections.html#deque-objects

	Need an object which has these properties:
		list to hold all the blocks that are changed
		list to hold all the previous block values
		list to hold which index of each block was changed